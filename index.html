// --- 유틸: onstop을 프로미스로 대기 ---
function waitForStop(rec) {
  return new Promise((resolve) => {
    const prevOnStop = rec.onstop;
    rec.onstop = (ev) => {
      try { prevOnStop && prevOnStop(ev); } catch {}
      resolve();
    };
  });
}

// --- Done: 정지 → 마지막 청크 강제 플러시 → onstop 확실히 대기 → 처리 ---
doneBtn.addEventListener('click', async () => {
  try {
    doneBtn.disabled = true;

    if (!mediaRecorder || mediaRecorder.state === 'inactive') {
      if (!lastDataURL) { alert('복사할 녹음이 없습니다.'); doneBtn.disabled = false; return; }
      await copyTextRobust(lastDataURL);
      location.href = "shortcuts://run-shortcut?name=" + encodeURIComponent(SHORTCUT_NAME);
      return;
    }

    // 사용자 제스처 콜스택에서 즉시 플로우 시작
    // 1) 마지막 버퍼를 강제로 요청 (타임슬라이스 경계 손실 방지)
    if (typeof mediaRecorder.requestData === 'function') {
      try { mediaRecorder.requestData(); } catch {}
    }

    // 2) onstop 대기 준비
    const stopped = waitForStop(mediaRecorder);

    // 3) 정지
    mediaRecorder.stop();

    // 4) onstop 이벤트가 실제로 끝날 때까지 기다림
    await stopped;

    // 5) 이후 처리(onStop에서 오류났다면 여기서 다시 안전 처리)
    await finalizeAfterStop();   // 아래 새 함수
  } catch (e) {
    console.error(e);
    alert('녹음 마무리 중 오류가 발생했습니다. (E1)');
    doneBtn.disabled = false;
  }
});

// 기존 onStop 내용은 블롭 생성만 남기고, 나머지는 별도 함수에서 처리
async function onStop(){
  try {
    clearInterval(timerTick);
    timerEl.textContent = '00:00';
    setRecUI(false);

    const type = (mediaRecorder && mediaRecorder.mimeType) || 'audio/mp4';
    lastMime = type;

    const blob = new Blob(chunks, { type });
    chunks = []; // reset
    try { player.src = URL.createObjectURL(blob); } catch {}

    lastDataURL = await blobToDataURL(blob); // 청크가 없어도 Data URL은 생성됨(빈 데이터)
    // 힌트용 제목
    const ext = type.includes('mp4') ? 'm4a' : (type.includes('webm') ? 'webm' : 'm4a');
    document.title = `Audio Ready (${ext})`;

  } catch (err) {
    console.error(err);
    // onStop 내부 에러는 finalize에서 한 번 더 방어
  } finally {
    // 노드/트랙 정리는 마지막에
    stopCaptureNodes();
  }
}

// onStop 이후 최종 단계 (클립보드 복사 → 단축어 실행)
async function finalizeAfterStop(){
  try {
    if (!lastDataURL || typeof lastDataURL !== 'string') {
      // 혹시 비어있으면 최소한의 무음 파일로 대체 혹은 사용자 안내
      alert('오디오 데이터가 비어 있습니다. 다시 시도해 주세요.');
      doneBtn.disabled = false;
      return;
    }
    await copyTextRobust(lastDataURL);
    location.href = "shortcuts://run-shortcut?name=" + encodeURIComponent(SHORTCUT_NAME);
  } catch (e) {
    console.error(e);
    alert('녹음 마무리 중 오류가 발생했습니다. (E2: copy/handoff)');
    doneBtn.disabled = false;
  }
}
