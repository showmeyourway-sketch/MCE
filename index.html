<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Record ‚Üí Shortcuts (Save Recording)</title>
<style>
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; padding:20px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0; }
  button { padding:10px 14px; border:0; border-radius:10px; background:#007aff; color:#fff; font-size:16px; }
  button[disabled]{ opacity:.5; }
  #timer { min-width:80px; font-variant-numeric:tabular-nums; }
  audio { width:100%; margin-top:12px; }
  #dataurl { position:absolute; left:-9999px; }
</style>
</head>
<body>
  <h1>Ïò§ÎîîÏò§ ÎÖπÏùå ‚Üí ShortcutsÎ°ú Ï†ÑÏÜ° (Save Recording)</h1>
  <div class="row">
    <button id="recordBtn">Record</button>
    <span id="timer">00:00</span>
  </div>
  <audio id="player" controls></audio>
  <textarea id="dataurl" readonly></textarea>

<script>
(() => {
  const qp = new URLSearchParams(location.search);
  const HANDLER   = qp.get('handler')   || 'Save Recording'; // üëà Ïó¨Í∏∞ Ïù¥Î¶Ñ Î≥ÄÍ≤ΩÎê®
  const CHUNK_LEN = parseInt(qp.get('chunksize')||'80000', 10);
  const recordBtn = document.getElementById('recordBtn');
  const timerEl   = document.getElementById('timer');
  const player    = document.getElementById('player');
  const dataTA    = document.getElementById('dataurl');

  let mediaRecorder=null, chunks=[], startTs=0, tickId=0;

  const fmt = ms => { const s=Math.floor(ms/1000), m=String(Math.floor(s/60)).padStart(2,'0'), ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; };
  const mh  = () => window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[HANDLER];
  const post= payload => { try { if (mh()) { mh().postMessage(payload); return true; } } catch(e){} return false; };
  const pickMime = () => {
    const list = ['audio/mp4;codecs=mp4a.40.2','audio/mp4','audio/webm;codecs=opus','audio/webm'];
    for (const m of list) if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
    return '';
  };
  const blobToDataURL = b => new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=rej; fr.readAsDataURL(b); });

  async function startRec(){
    if (!navigator.mediaDevices?.getUserMedia) { alert('Ïù¥ ÌôòÍ≤ΩÏóêÏÑúÎäî ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑ºÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§. HTTPS ÎòêÎäî localhostÎ°ú Ïã§ÌñâÌïòÏÑ∏Ïöî.'); return; }
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    chunks = [];
    const mime = pickMime();
    mediaRecorder = mime ? new MediaRecorder(stream, { mimeType: mime }) : new MediaRecorder(stream);

    mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
    mediaRecorder.onstop = async () => {
      const type = mediaRecorder.mimeType || 'audio/mp4';
      const blob = new Blob(chunks, { type });
      const ext  = type.includes('mp4') ? 'm4a' : (type.includes('webm') ? 'webm' : 'm4a');
      const name = `recording_${new Date().toISOString().replace(/[:.]/g,'-')}.${ext}`;
      player.src = URL.createObjectURL(blob);

      const dataURL = await blobToDataURL(blob);
      dataTA.value = dataURL;
      document.title = `Audio Ready: ${name}`;

      const base64 = dataURL.slice(dataURL.indexOf(',')+1);
      const total  = Math.ceil(base64.length / CHUNK_LEN);
      const id     = `rec-${Date.now()}`;

      const bridged = post({ type:'audioStart', id, name, mime:type, total });
      if (bridged) {
        for (let i=0;i<total;i++){
          post({ type:'audioChunk', id, idx:i, data: base64.slice(i*CHUNK_LEN, (i+1)*CHUNK_LEN) });
        }
        post({ type:'audioDone', id });
      }

      resetUI();
    };

    startTs = Date.now();
    timerEl.textContent = '00:00';
    tickId = setInterval(()=> timerEl.textContent = fmt(Date.now()-startTs), 250);
    mediaRecorder.start(250);
    recordBtn.textContent = 'Stop';
  }

  function stopRec(){
    if (!mediaRecorder) return;
    mediaRecorder.stop();
    mediaRecorder.stream.getTracks().forEach(t=>t.stop());
    clearInterval(tickId);
  }

  function resetUI(){
    mediaRecorder = null;
    clearInterval(tickId);
    timerEl.textContent = '00:00';
    recordBtn.textContent = 'Record';
  }

  async function onRecordClick(){
    if (mediaRecorder && mediaRecorder.state === 'recording') stopRec();
    else {
      try { await startRec(); }
      catch(e){ console.error(e); alert('ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÎòêÎäî ÎÖπÏùå ÏãúÏûë Ïã§Ìå®.\n‚Ä¢ HTTPS/localhostÏù∏ÏßÄ ÌôïÏù∏\n‚Ä¢ ÏÑ§Ï†ï > Safari > ÎßàÏù¥ÌÅ¨ ÌóàÏö©'); resetUI(); }
    }
  }

  recordBtn.addEventListener('click', onRecordClick);
  post({ type:'ready', ts:Date.now() });
})();
</script>
</body>
</html>
