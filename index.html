<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Record → Save to iCloud Drive</title>
<style>
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; padding:20px; }
  h1 { font-size:18px; margin:0 0 10px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0; }
  button { padding:10px 14px; border:0; border-radius:10px; background:#007aff; color:#fff; font-size:16px; }
  button[disabled]{ opacity:.5; }
  #timer { min-width:80px; font-variant-numeric:tabular-nums; }
  audio { width:100%; margin-top:12px; }
  #hint { color:#666; font-size:13px; margin-top:8px; line-height:1.5; }
</style>
</head>
<body>
  <h1>오디오 녹음 → iCloud Drive 저장</h1>
  <div class="row">
    <button id="recordBtn">Record</button>
    <span id="timer">00:00</span>
  </div>
  <audio id="player" controls></audio>
  <div id="hint">
    • HTTPS 또는 localhost에서 사용하세요. 처음 사용 시 마이크 권한을 허용해야 합니다.<br/>
    • 저장은 iOS 공유 시트의 <b>“파일에 저장”</b>을 통해 iCloud Drive 위치를 선택합니다.
  </div>

<script>
(() => {
  const recordBtn = document.getElementById('recordBtn');
  const timerEl   = document.getElementById('timer');
  const player    = document.getElementById('player');

  let mediaRecorder = null;
  let chunks = [];
  let startTs = 0;
  let tickId = 0;
  let lastBlob = null;
  let lastFileName = '';

  function fmt(ms){
    const s=Math.floor(ms/1000);
    const mm=String(Math.floor(s/60)).padStart(2,'0');
    const ss=String(s%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  function pickMime(){
    const cands = [
      'audio/mp4;codecs=mp4a.40.2', // m4a (Safari 친화)
      'audio/mp4',
      'audio/webm;codecs=opus',
      'audio/webm'
    ];
    for(const m of cands){
      if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
    }
    return ''; // 브라우저 기본값
  }

  async function startRecording(){
    const hasGUM = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    if(!hasGUM){ alert('이 환경에서는 마이크 접근을 지원하지 않습니다.'); return; }

    // 스트림 요청(사용자 제스처 내부)
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    chunks = [];
    const mime = pickMime();
    try {
      mediaRecorder = mime ? new MediaRecorder(stream, { mimeType: mime }) : new MediaRecorder(stream);
    } catch(e) {
      stream.getTracks().forEach(t=>t.stop());
      throw e;
    }

    mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size>0) chunks.push(e.data); };
    mediaRecorder.onstop = async () => {
      // Blob 생성
      const type = mediaRecorder.mimeType || 'audio/mp4';
      lastBlob = new Blob(chunks, { type });
      const ext = (type.includes('mp4')) ? 'm4a' : (type.includes('webm') ? 'webm' : 'm4a');
      lastFileName = `recording_${new Date().toISOString().replace(/[:.]/g,'-')}.${ext}`;
      player.src = URL.createObjectURL(lastBlob);

      // 공유 시트 자동 호출 시도 (일부 환경에선 제스처 컨텍스트가 아니라 막힐 수 있음)
      const auto = await tryShareFile(lastBlob, lastFileName);

      if (!auto) {
        // 자동 호출이 막히면 버튼을 "Save to Files" 모드로 전환
        recordBtn.textContent = 'Save to Files';
        recordBtn.onclick = async () => {
          const ok = await tryShareFile(lastBlob, lastFileName);
          if (ok) {
            // 저장 이후 다시 Record로 복구
            resetToRecord();
          } else {
            // 마지막 폴백: 파일 열기(다운로드) 후 공유 시트에서 "파일에 저장"
            fallbackDownload(lastBlob, lastFileName);
            resetToRecord();
          }
        };
      } else {
        // 성공 시 원래 상태로 복귀
        resetToRecord();
      }
    };

    // 타이머/상태
    startTs = Date.now();
    timerEl.textContent = '00:00';
    tickId = setInterval(()=> timerEl.textContent = fmt(Date.now()-startTs), 250);

    // 시작
    mediaRecorder.start(250);
    recordBtn.textContent = 'Stop';
  }

  function stopRecording(){
    if (!mediaRecorder) return;
    mediaRecorder.stop();
    mediaRecorder.stream.getTracks().forEach(t=>t.stop());
    clearInterval(tickId);
  }

  async function tryShareFile(blob, name){
    try {
      const file = new File([blob], name, { type: blob.type || 'audio/mp4' });
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: '녹음 파일',
          text: '“파일에 저장”을 탭해 iCloud Drive에 저장하세요.'
        });
        return true;
      }
    } catch(e) {
      // 사용자 취소 등은 조용히 실패 처리
    }
    return false;
  }

  function fallbackDownload(blob, name){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    alert('공유 시트를 열 수 없어 파일을 다운로드했습니다. 파일을 열어 “공유” → “파일에 저장”으로 iCloud Drive에 저장하세요.');
  }

  function resetToRecord(){
    mediaRecorder = null;
    clearInterval(tickId);
    timerEl.textContent = '00:00';
    recordBtn.textContent = 'Record';
    recordBtn.onclick = handleRecordClick;
  }

  async function handleRecordClick(){
    // 토글: 녹음 중이면 정지, 아니면 시작
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      stopRecording();
    } else {
      try {
        await startRecording();
      } catch (e) {
        console.error(e);
        alert('마이크 권한 또는 녹음 시작에 실패했습니다.\n• HTTPS 또는 localhost에서 실행 중인지 확인하세요.\n• iOS 설정 > Safari > 마이크: 허용/요청.');
        resetToRecord();
      }
    }
  }

  // 초기 바인딩
  recordBtn.onclick = handleRecordClick;

  // 안내: HTTPS/localhost 체크 (선택)
  if (!(location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1')) {
    console.warn('권장: HTTPS 또는 localhost에서 실행하세요 (마이크 권한 요구).');
  }
})();
</script>
</body>
</html>
