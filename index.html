<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Auto Recording + VU → Save Recording (Data URL)</title>
<style>
  :root { --primary:#007aff; --danger:#ff3b30; --border:#dadada; }
  body { font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin:18px; }
  h1 { font-size:18px; margin:0 0 12px; }
  .card { border:1px solid var(--border); border-radius:12px; padding:14px; }
  .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .badge { font-size:12px; padding:4px 8px; border-radius:999px; background:#f2f2f7; border:1px solid #e5e5ea; }
  .rec { color:#fff; background:var(--danger); border-color:var(--danger); }
  .btn { padding:11px 14px; border:none; border-radius:10px; background:var(--primary); color:#fff; font-size:16px; }
  .btn:disabled { opacity:.6 }
  .btn.secondary { background:#e9e9ed; color:#111; }
  .meter-wrap { margin-top:12px; height:16px; border-radius:999px; background:#f2f2f7; border:1px solid #e5e5ea; overflow:hidden; }
  .meter-bar { height:100%; width:0%; background:linear-gradient(90deg,#34c759,#ffcc00,#ff3b30); transition:width .08s linear; }
  .mono { font-variant-numeric:tabular-nums; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
</style>
</head>
<body>

<h1>Recording… with Live VU</h1>

<div class="card">
  <div class="row" id="statusRow">
    <span class="badge" id="perm">Mic: requesting…</span>
    <span class="badge" id="state">Recorder: idle</span>
    <span class="badge rec" id="recDot" style="display:none;">● REC</span>
    <span class="badge mono" id="timer">00:00</span>
    <button id="enableBtn" class="btn secondary" style="display:none;">Enable Audio</button>
  </div>

  <div class="meter-wrap" aria-label="VU meter">
    <div class="meter-bar" id="meterBar"></div>
  </div>

  <div class="row" style="margin-top:14px;">
    <button id="doneBtn" class="btn">Done</button>
  </div>
</div>

<script>
(() => {
  const permEl   = document.getElementById('perm');
  const stateEl  = document.getElementById('state');
  const recDot   = document.getElementById('recDot');
  const meterBar = document.getElementById('meterBar');
  const enableBtn= document.getElementById('enableBtn');
  const timerEl  = document.getElementById('timer');
  const doneBtn  = document.getElementById('doneBtn');

  let stream=null, ctx=null, analyser=null, srcNode=null, rafId=null;
  let mediaRecorder=null, chunks=[], startedAt=0, timerTick=null;
  const shortcutName = "Save Recording"; // ← 이 단축어 실행

  document.addEventListener('DOMContentLoaded', autoStart);

  async function autoStart(){
    try{
      permEl.textContent = 'Mic: requesting…';
      stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      permEl.textContent = 'Mic: granted';

      ctx = new (window.AudioContext || window.webkitAudioContext)();
      await tryResumeAudio();

      analyser = ctx.createAnalyser();
      analyser.fftSize = 2048;
      srcNode = ctx.createMediaStreamSource(stream);
      srcNode.connect(analyser);

      startVU();
      startTimer();

      const types = [
        'audio/mp4;codecs=mp4a.40.2',
        'audio/mp4',
        'audio/aac',
        'audio/webm;codecs=opus',
        'audio/webm'
      ];
      let mime = '';
      for (const t of types) {
        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) { mime = t; break; }
      }
      mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);
      mediaRecorder.onstart = () => setRecUI(true);
      mediaRecorder.onstop  = onStop;
      mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size) chunks.push(e.data); };

      mediaRecorder.start(1000); // 즉시 녹음 시작
      stateEl.textContent = 'Recorder: starting…';
    }catch(err){
      console.error(err);
      permEl.textContent = 'Mic: denied or error';
      stateEl.textContent = 'Recorder: error';
      enableBtn.style.display = 'inline-block';
      enableBtn.onclick = ()=>location.reload();
    }
  }

  async function tryResumeAudio(){
    if (ctx.state === 'suspended') { try { await ctx.resume(); } catch {} }
    if (ctx.state !== 'running') {
      enableBtn.style.display = 'inline-block';
      enableBtn.onclick = async ()=>{ try { await ctx.resume(); } catch {} if(ctx.state==='running') enableBtn.style.display='none'; };
    }
  }

  function setRecUI(isRec){
    stateEl.textContent = isRec ? 'Recorder: recording' : 'Recorder: stopped';
    recDot.style.display = isRec ? 'inline-block' : 'none';
  }

  function startVU(){
    const buf = new Uint8Array(analyser.fftSize);
    const floor = -60;
    function tick(){
      analyser.getByteTimeDomainData(buf);
      let sum=0;
      for (let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum += v*v; }
      const rms = Math.sqrt(sum/buf.length);
      let db = 20*Math.log10(rms || 1e-8);
      if(!isFinite(db)) db = floor;
      if(db<floor) db=floor;
      const pct = Math.max(0, Math.min(100, ((db-floor)/(0-floor))*100));
      meterBar.style.width = pct.toFixed(0)+'%';
      rafId = requestAnimationFrame(tick);
    }
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tick);
  }

  function startTimer(){
    startedAt = Date.now();
    timerEl.textContent = '00:00';
    clearInterval(timerTick);
    timerTick = setInterval(()=>{
      const s = Math.floor((Date.now()-startedAt)/1000);
      const mm = String(Math.floor(s/60)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      timerEl.textContent = `${mm}:${ss}`;
    }, 500);
  }

  // Done → 녹음 정지 → Data URL로 변환 → Shortcuts 호출
  doneBtn.addEventListener('click', ()=>{
    doneBtn.disabled = true;
    stopCapture();
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop(); // onStop에서 처리
    } else {
      window.close?.();
    }
  });

  function stopCapture(){
    if (srcNode) try{ srcNode.disconnect(); }catch{}
    if (analyser) try{ analyser.disconnect(); }catch{}
    if (stream) stream.getTracks().forEach(t=>t.stop());
    if (ctx && ctx.state !== 'closed') ctx.close();
    cancelAnimationFrame(rafId);
    clearInterval(timerTick);
    setRecUI(false);
  }

  async function onStop(){
    try{
      const type = (mediaRecorder && mediaRecorder.mimeType) || 'audio/mp4';
      const blob = new Blob(chunks, { type });
      const dataURL = await blobToDataURL(blob); // ← 전체 Data URL 문자열

      // Data URL을 그대로 input으로 전달 (디코딩 불필요)
      const url = "shortcuts://run-shortcut?name=" +
        encodeURIComponent(shortcutName) +
        "&input=" + encodeURIComponent(dataURL);

      // 단축어 실행
      window.location.href = url;
    }catch(err){
      console.error(err);
      alert('Failed to hand off to Shortcuts.');
    }
  }

  function blobToDataURL(blob){
    return new Promise((resolve, reject)=>{
      const fr = new FileReader();
      fr.onerror = reject;
      fr.onload = ()=> resolve(fr.result); // "data:audio/xxx;base64,AAAA..."
      fr.readAsDataURL(blob);
    });
  }
})();
</script>
</body>
</html>
