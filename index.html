<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Record → Done → Run Shortcut (Multiline)</title>
<style>
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; padding:20px; }
  h1 { font-size:18px; margin:0 0 10px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0; }
  button { padding:10px 14px; border:0; border-radius:10px; color:#fff; font-size:16px; cursor:pointer; }
  #recordBtn { background:#007aff; }
  #recordBtn.danger { background:#ff3b30; } /* Stop 상태 */
  #recordBtn.done { background:#34c759; }   /* Done 상태 */
  #timer { min-width:80px; font-variant-numeric: tabular-nums; margin-left:10px; }
  audio { width:100%; margin-top:12px; }

  /* 전달된 텍스트 표시용 */
  .incoming-wrap { margin:12px 0 16px; padding:10px 12px; border:1px solid #e5e5ea; border-radius:10px; background:#f7f7f9; }
  .incoming-label { font-size:12px; color:#666; margin-bottom:6px; }
  .incoming-text { white-space:pre-wrap; word-break:break-word; font-size:16px; }

  /* execCommand 폴백용 숨김 영역 */
  #b64, #dataurl { position:fixed; bottom:-9999px; left:0; width:1px; height:1px; opacity:0.001; }

  /* 메타 저장용 숨김 입력 */
  .hidden { position:fixed; left:-9999px; width:1px; height:1px; opacity:0; }
</style>
</head>
<body>
  <h1>오디오 녹음</h1>

  <!-- ▼ 전달받은 텍스트 표시 영역 -->
  <div class="incoming-wrap" id="incomingBox" style="display:none;">
    <div class="incoming-label">Received text</div>
    <div class="incoming-text" id="incomingText"></div>
  </div>

  <div class="row">
    <button id="recordBtn">Record</button>
    <span id="timer">00:00</span>
  </div>

  <audio id="player" controls></audio>

  <!-- 폴백/데이터 보관 -->
  <textarea id="b64" class="hidden" readonly></textarea>
  <textarea id="dataurl" class="hidden" readonly></textarea>

  <!-- 메타 저장용 (name/title/subtitle) -->
  <input id="metaName" class="hidden" readonly />
  <input id="metaTitle" class="hidden" readonly />
  <input id="metaSubtitle" class="hidden" readonly />

<script>
(() => {
  // ---------- DOM 요소 선택 ----------
  const recordBtn = document.getElementById('recordBtn');
  const timerEl   = document.getElementById('timer');
  const player    = document.getElementById('player');
  const b64TA     = document.getElementById('b64');
  const dataTA    = document.getElementById('dataurl');
  const metaNameEl = document.getElementById('metaName');
  const metaTitleEl = document.getElementById('metaTitle');
  const metaSubtitleEl = document.getElementById('metaSubtitle');
  const incomingBox = document.getElementById('incomingBox');
  const incomingText = document.getElementById('incomingText');

  // ---------- 전달된 텍스트(4줄) 파싱 ----------
  function readIncoming4Lines() {
    const getRaw = () => {
      const qs = new URLSearchParams(location.search);
      let v = qs.get('message');
      if (!v && location.hash) {
        const h = location.hash.replace(/^#/, '');
        if (h.startsWith('message=')) v = h.slice('message='.length);
        else v = decodeURIComponent(h);
      }
      return v || '';
    };
    let raw = getRaw();
    try { raw = decodeURIComponent(raw); } catch {}
    const lines = raw.split(/\r?\n/);
    return {
      name:      lines[0] || '',
      title:     lines[1] || '',
      subtitle:  lines[2] || '',
      received:  lines[3] || ''
    };
  }

  const incoming = readIncoming4Lines();
  // 메타 저장
  metaNameEl.value = incoming.name;
  metaTitleEl.value = incoming.title;
  metaSubtitleEl.value = incoming.subtitle;
  // 화면 표시(4번째 줄만)
  if (incoming.received) {
    incomingText.innerText = incoming.received;
    incomingBox.style.display = 'block';
  }

  // ---------- 녹음 기능 ----------
  const qs = new URLSearchParams(location.search);
  const SHORTCUT_NAME = (qs.get('shortcut') || 'Save Recording').trim();

  let mediaRecorder=null, chunks=[], startTs=0, tickId=0;
  let lastBase64='', lastName='', lastMime='';

  const fmt = ms => {
    const s=Math.floor(ms/1000),
          m=String(Math.floor(s/60)).padStart(2,'0'),
          ss=String(s%60).padStart(2,'0');
    return `${m}:${ss}`;
  };
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function pickMime(){
    const cands = [
      'audio/mp4;codecs=mp4a.40.2',
      'audio/mp4',
      'audio/webm;codecs=opus',
      'audio/webm'
    ];
    for (const m of cands){
      if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
    }
    return '';
  }

  function blobToDataURL(blob){
    return new Promise((res,rej)=>{
      const fr=new FileReader();
      fr.onload = ()=>res(fr.result);
      fr.onerror= rej;
      fr.readAsDataURL(blob);
    });
  }

  async function copyTextRobust(text){
    try{
      if ((location.protocol === 'https:' || ['localhost','127.0.0.1'].includes(location.hostname))
          && navigator.clipboard && window.isSecureContext){
        await navigator.clipboard.writeText(text);
        return;
      }
    }catch(e){}
    try{
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.setAttribute('readonly','');
      ta.style.position = 'fixed';
      ta.style.left = '0'; ta.style.bottom = '0'; ta.style.opacity = '0.001';
      document.body.appendChild(ta);
      ta.focus(); ta.select(); ta.setSelectionRange(0, ta.value.length);
      const ok = document.execCommand('copy');
      document.body.removeChild(ta);
      if (ok) return;
    }catch(e){}
    b64TA.value = text;
    b64TA.focus(); b64TA.select(); b64TA.setSelectionRange(0, b64TA.value.length);
    const ok3 = document.execCommand('copy');
    if (ok3) return;
    throw new Error('Copy failed');
  }

  async function startRec(){
    if (!navigator.mediaDevices?.getUserMedia){
      alert('이 환경에서는 마이크 접근을 지원하지 않습니다.');
      return;
    }
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    chunks = [];
    const mime = pickMime();
    // 64kbps로 용량 절감
    const options = mime
      ? { mimeType: mime, audioBitsPerSecond: 64000 }
      : { audioBitsPerSecond: 64000 };
    mediaRecorder = new MediaRecorder(stream, options);

    mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
    mediaRecorder.onstop = async () => {
      clearInterval(tickId);
      timerEl.textContent = '00:00';
      const type = mediaRecorder.mimeType || 'audio/mp4';
      const blob = new Blob(chunks, { type });
      lastMime = type;
      const ext  = type.includes('mp4') ? 'm4a' : (type.includes('webm') ? 'webm' : 'm4a');
      // 파일명은 name이 있으면 우선 사용, 없으면 timestamp
      const baseName = metaNameEl.value.trim() || 'recording_' + new Date().toISOString().replace(/[:.]/g,'-');
      lastName = `${baseName}.${ext}`;
      player.src = URL.createObjectURL(blob);

      try {
        const dataURL = await blobToDataURL(blob);
        dataTA.value = dataURL;
        lastBase64 = dataURL.slice(dataURL.indexOf(',')+1);
        b64TA.value = lastBase64;

        // 문서 제목에도 남겨두기
        document.title = `Audio Ready: ${lastName}`;

        // Stop → Done 으로 전환
        recordBtn.textContent = 'Done';
        recordBtn.classList.remove('danger');
        recordBtn.classList.add('done');
      } catch(e) {
        console.error('Data URL 변환 실패:', e);
        alert('녹음 파일 처리 중 오류가 발생했습니다.');
      }
    };

    startTs = Date.now();
    tickId = setInterval(()=> timerEl.textContent = fmt(Date.now()-startTs), 250);
    mediaRecorder.start(250);
    recordBtn.textContent = 'Ready';
    recordBtn.classList.add('danger');
    recordBtn.disabled = true;
    await sleep(1000);
    recordBtn.textContent = 'Stop';
    recordBtn.disabled = false;
  }

  async function stopRec(){
    if (!mediaRecorder) return;
    mediaRecorder.stop();
    try { mediaRecorder.stream.getTracks().forEach(t=>t.stop()); } catch {}
  }

  async function onRecordClick(){
    const label = recordBtn.textContent.trim();
    if (label === 'Record') {
      try {
        await startRec();
      } catch(e){
        console.error(e);
        alert('마이크 권한 또는 녹음 시작 실패.');
        clearInterval(tickId);
        timerEl.textContent = '00:00';
        recordBtn.textContent = 'Record';
        recordBtn.className = '';
        recordBtn.disabled = false;
        mediaRecorder = null;
      }
    } else if (label === 'Stop') {
      await stopRec();
    } else if (label === 'Done') {
      if (!dataTA.value) {
        alert('복사할 녹음이 없습니다.');
        return;
      }
      // 멀티라인 페이로드: name, title, subtitle, received, dataURL(5행)
      const payload = [
        metaNameEl.value || '',
        metaTitleEl.value || '',
        metaSubtitleEl.value || '',
        incoming.received || '',
        dataTA.value || ''
      ].join('\n');

      try {
        await copyTextRobust(payload);
        const url = "shortcuts://run-shortcut?name=" + encodeURIComponent(SHORTCUT_NAME);
        location.href = url;
      } catch {
        alert('클립보드 복사 실패');
      }
    }
  }

  recordBtn.addEventListener('click', onRecordClick);
})();
</script>
</body>
</html>
