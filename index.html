<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Auto Record + VU → Clipboard → Run Shortcut</title>
<style>
  :root { --primary:#007aff; --danger:#ff3b30; --border:#dadada; }
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif; padding:20px; }
  h1 { font-size:18px; margin:0 0 10px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0; }
  button { padding:10px 14px; border:0; border-radius:10px; background:#007aff; color:#fff; font-size:16px; }
  button[disabled]{ opacity:.5; }
  .badge { font-size:12px; padding:4px 8px; border-radius:999px; background:#f2f2f7; border:1px solid #e5e5ea; }
  .rec   { color:#fff; background:var(--danger); border-color:var(--danger); }
  #timer { min-width:80px; font-variant-numeric: tabular-nums; }
  audio { width:100%; margin-top:12px; }
  .meter-wrap { margin-top:8px; height:16px; border-radius:999px; background:#f2f2f7; border:1px solid #e5e5ea; overflow:hidden; }
  .meter-bar { height:100%; width:0%; background:linear-gradient(90deg,#34c759,#ffcc00,#ff3b30); transition:width .08s linear; }
  /* execCommand 폴백용 숨김 영역 (iOS용 실제 선택 필요 시 화면 안쪽 배치) */
  #hiddenTA { position:fixed; bottom:-9999px; left:0; width:1px; height:1px; opacity:0.001; }
</style>
</head>
<body>
  <h1>오디오 녹음</h1>
  <div class="row">
    <span class="badge" id="perm">Mic: requesting…</span>
    <span class="badge" id="state">Recorder: idle</span>
    <span class="badge rec" id="recDot" style="display:none;">● REC</span>
    <span class="badge" id="timer">00:00</span>
    <button id="enableBtn" style="display:none; background:#e9e9ed; color:#111;">Enable Audio</button>
  </div>

  <div class="meter-wrap" aria-label="VU meter">
    <div class="meter-bar" id="meterBar"></div>
  </div>

  <div class="row">
    <button id="doneBtn" disabled>Done</button>
  </div>

  <audio id="player" controls></audio>

  <!-- 클립보드 폴백용 -->
  <textarea id="hiddenTA" readonly></textarea>

<script>
(() => {
  // ======== 설정 ========
  const qs = new URLSearchParams(location.search);
  const SHORTCUT_NAME = (qs.get('shortcut') || 'Save Recording').trim();

  // ======== 엘리먼트 ========
  const permEl    = document.getElementById('perm');
  const stateEl   = document.getElementById('state');
  const recDot    = document.getElementById('recDot');
  const timerEl   = document.getElementById('timer');
  const meterBar  = document.getElementById('meterBar');
  const enableBtn = document.getElementById('enableBtn');
  const doneBtn   = document.getElementById('doneBtn');
  const player    = document.getElementById('player');
  const hiddenTA  = document.getElementById('hiddenTA');

  // ======== 상태 ========
  let stream=null, ctx=null, analyser=null, srcNode=null, rafId=null;
  let mediaRecorder=null, chunks=[], startedAt=0, timerTick=null;
  let lastDataURL='', lastMime='';

  // ======== 유틸 ========
  const fmt = ms => {
    const s=Math.floor(ms/1000);
    return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
  };

  function pickMime(){
    const cands = [
      'audio/mp4;codecs=mp4a.40.2', // m4a 선호(사파리 친화)
      'audio/mp4',
      'audio/webm;codecs=opus',
      'audio/webm'
    ];
    for (const m of cands){
      if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
    }
    return '';
  }

  function blobToDataURL(blob){
    return new Promise((res,rej)=>{
      const fr=new FileReader();
      fr.onload = ()=>res(fr.result); // "data:audio/...;base64,AAAA..."
      fr.onerror= rej;
      fr.readAsDataURL(blob);
    });
  }

  async function copyTextRobust(text){
    // 1) 최신 API (보안 맥락 필요)
    try{
      if ((location.protocol === 'https:' || ['localhost','127.0.0.1'].includes(location.hostname))
          && navigator.clipboard && window.isSecureContext){
        await navigator.clipboard.writeText(text);
        return;
      }
    }catch(e){}
    // 2) execCommand 폴백
    try{
      hiddenTA.value = text;
      hiddenTA.focus(); hiddenTA.select(); hiddenTA.setSelectionRange(0, hiddenTA.value.length);
      const ok = document.execCommand('copy');
      if (ok) return;
    }catch(e){}
    throw new Error('Copy failed');
  }

  function waitForStop(rec) {
    return new Promise((resolve) => {
      const prev = rec.onstop;
      rec.onstop = (ev) => {
        try { prev && prev(ev); } catch {}
        resolve();
      };
    });
  }

  // ======== 자동 시작 ========
  document.addEventListener('DOMContentLoaded', autoStart);

  async function autoStart(){
    try{
      permEl.textContent = 'Mic: requesting…';
      stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      permEl.textContent = 'Mic: granted';

      // WebAudio for VU
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      await tryResumeAudio();

      analyser = ctx.createAnalyser();
      analyser.fftSize = 2048;
      srcNode = ctx.createMediaStreamSource(stream);
      srcNode.connect(analyser);

      startVU();
      startTimer();

      // MediaRecorder
      const mime = pickMime();
      mediaRecorder = mime ? new MediaRecorder(stream, { mimeType: mime }) : new MediaRecorder(stream);
      mediaRecorder.onstart = () => setRecUI(true);
      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = onStop;

      mediaRecorder.start(250); // 즉시 시작(짧은 타임슬라이스로 청크 손실 최소화)
      stateEl.textContent = 'Recorder: starting…';

      // 녹음 시작 인지되면 Done 활성화
      const enabler = setInterval(()=>{
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          doneBtn.disabled = false; clearInterval(enabler);
        }
      }, 150);
    }catch(err){
      console.error(err);
      permEl.textContent = 'Mic: denied or error';
      stateEl.textContent = 'Recorder: error';
      enableBtn.style.display = 'inline-block';
      enableBtn.onclick = ()=>location.reload();
    }
  }

  async function tryResumeAudio(){
    if (ctx.state === 'suspended') { try { await ctx.resume(); } catch {} }
    if (ctx.state !== 'running') {
      enableBtn.style.display = 'inline-block';
      enableBtn.onclick = async ()=>{ try { await ctx.resume(); } catch {} if(ctx.state==='running') enableBtn.style.display='none'; };
    }
  }

  function setRecUI(isRec){
    stateEl.textContent = isRec ? 'Recorder: recording' : 'Recorder: stopped';
    recDot.style.display = isRec ? 'inline-block' : 'none';
  }

  // ======== VU ========
  function startVU(){
    const buf = new Uint8Array(analyser.fftSize);
    const floor = -60;
    function tick(){
      analyser.getByteTimeDomainData(buf);
      let sum=0; for (let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum += v*v; }
      const rms = Math.sqrt(sum/buf.length);
      let db = 20*Math.log10(rms || 1e-8);
      if(!isFinite(db)) db = floor;
      if(db<floor) db=floor;
      const pct = Math.max(0, Math.min(100, ((db-floor)/(0-floor))*100));
      meterBar.style.width = pct.toFixed(0)+'%';
      rafId = requestAnimationFrame(tick);
    }
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tick);
  }

  function startTimer(){
    startedAt = Date.now();
    timerEl.textContent = '00:00';
    clearInterval(timerTick);
    timerTick = setInterval(()=> timerEl.textContent = fmt(Date.now()-startedAt), 250);
  }

  function stopCaptureNodes(){
    if (srcNode) try{ srcNode.disconnect(); }catch{}
    if (analyser) try{ analyser.disconnect(); }catch{}
    if (stream) stream.getTracks().forEach(t=>t.stop());
    if (ctx && ctx.state !== 'closed') ctx.close();
    cancelAnimationFrame(rafId);
    clearInterval(timerTick);
    setRecUI(false);
  }

  // ======== Done: 정지 → 마지막 청크 플러시 → onstop 대기 → 최종 처리 ========
  doneBtn.addEventListener('click', async () => {
    try {
      doneBtn.disabled = true;

      if (!mediaRecorder || mediaRecorder.state === 'inactive') {
        if (!lastDataURL) { alert('복사할 녹음이 없습니다.'); doneBtn.disabled = false; return; }
        await copyTextRobust(lastDataURL);
        location.href = "shortcuts://run-shortcut?name=" + encodeURIComponent(SHORTCUT_NAME);
        return;
      }

      // 사용자 제스처 콜스택에서 즉시 플로우 시작
      if (typeof mediaRecorder.requestData === 'function') {
        try { mediaRecorder.requestData(); } catch {}
      }
      const stopped = waitForStop(mediaRecorder);
      mediaRecorder.stop();
      await stopped;          // onstop 완료 대기
      await finalizeAfterStop(); // 클립보드 복사 → 단축어 실행
    } catch (e) {
      console.error(e);
      alert('녹음 마무리 중 오류가 발생했습니다. (E1)');
      doneBtn.disabled = false;
    }
  });

  // onstop: 블롭/데이터URL 생성까지 담당 (에러는 finalize에서 한 번 더 방어)
  async function onStop(){
    try{
      clearInterval(timerTick);
      timerEl.textContent = '00:00';

      const type = (mediaRecorder && mediaRecorder.mimeType) || 'audio/mp4';
      lastMime = type;

      const blob = new Blob(chunks, { type });
      chunks = []; // reset
      try { player.src = URL.createObjectURL(blob); } catch {}

      lastDataURL = await blobToDataURL(blob); // 전체 Data URL
      // 힌트용 제목
      const ext = type.includes('mp4') ? 'm4a' : (type.includes('webm') ? 'webm' : 'm4a');
      document.title = `Audio Ready (${ext})`;
    } catch (err) {
      console.error(err);
    } finally {
      stopCaptureNodes();
    }
  }

  // onstop 이후 최종 단계 (클립보드 복사 → 단축어 실행)
  async function finalizeAfterStop(){
    try {
      if (!lastDataURL || typeof lastDataURL !== 'string' || !lastDataURL.startsWith('data:')) {
        alert('오디오 데이터가 비어 있습니다. 다시 시도해 주세요.');
        doneBtn.disabled = false;
        return;
      }
      await copyTextRobust(lastDataURL);
      location.href = "shortcuts://run-shortcut?name=" + encodeURIComponent(SHORTCUT_NAME);
    } catch (e) {
      console.error(e);
      alert('녹음 마무리 중 오류가 발생했습니다. (E2: copy/handoff)');
      doneBtn.disabled = false;
    }
  }

  // 참고: HTTPS/localhost 권장
  if (!(location.protocol === 'https:' || ['localhost','127.0.0.1'].includes(location.hostname))) {
    console.warn('HTTPS 또는 localhost에서 실행해야 마이크/클립보드가 안정적으로 동작합니다.');
  }
})();
</script>
</body>
</html>
