<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Record → Shortcuts (with Fallback)</title>
<style>
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; padding:20px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0; }
  button { padding:10px 14px; border:0; border-radius:10px; background:#007aff; color:#fff; font-size:16px; }
  button[disabled]{ opacity:.5; }
  #timer { min-width:80px; font-variant-numeric:tabular-nums; }
  audio { width:100%; margin-top:10px; }
  #log { font-size:13px; color:#666; white-space:pre-wrap; margin-top:8px; }
  /* 백업: Get Details of Web Page로 읽을 값 보관 */
  #meta, #dataurl { position:absolute; left:-9999px; }
  /* 숨겨진 시스템 녹음 폴백 입력 */
  #fileInput { display:none; }
</style>
</head>
<body>
  <h1>오디오 녹음 → Shortcuts 전달</h1>
  <div class="row">
    <button id="recBtn">녹음 시작</button>
    <button id="stopBtn" disabled>정지</button>
    <button id="pickBtn">시스템 녹음/파일 선택(폴백)</button>
    <span id="timer">00:00</span>
  </div>
  <div class="row">
    <button id="sendBtn" disabled>전송(Shortcuts)</button>
    <span id="status"></span>
  </div>
  <audio id="player" controls></audio>
  <div id="log"></div>

  <!-- 폴백 입력: iOS는 capture="microphone"로 시스템 녹음 UI를 띄울 수 있음 -->
  <input id="fileInput" type="file" accept="audio/*" capture="microphone">

  <!-- 백업: 제목/본문으로 최소 정보 남김 -->
  <textarea id="meta" readonly></textarea>
  <textarea id="dataurl" readonly></textarea>

<script>
(() => {
  const qp = new URLSearchParams(location.search);
  const HANDLER = qp.get('handler') || 'shortcut';            // Receive Web Page Messages 이름
  const CHUNK_CHARS = parseInt(qp.get('chunksize')||'80000'); // 청크 크기
  const recBtn  = document.getElementById('recBtn');
  const stopBtn = document.getElementById('stopBtn');
  const pickBtn = document.getElementById('pickBtn');
  const sendBtn = document.getElementById('sendBtn');
  const timerEl = document.getElementById('timer');
  const statusEl= document.getElementById('status');
  const player  = document.getElementById('player');
  const logEl   = document.getElementById('log');
  const metaTA  = document.getElementById('meta');
  const dataTA  = document.getElementById('dataurl');
  const fileIn  = document.getElementById('fileInput');

  let mediaRecorder, chunks=[], startTs=0, tickId=0;
  let mime='', ext='webm', blob=null, fileName='';

  const log = s => (logEl.textContent += s + '\n');
  const fmt = ms => { const s=Math.floor(ms/1000), m=String(Math.floor(s/60)).padStart(2,'0'), ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; };
  const mh  = () => (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[HANDLER]);
  const postToShortcuts = payload => { try { if (mh()) { mh().postMessage(payload); return true; } } catch(e){} return false; };
  const setMeta = s => { document.title = s; metaTA.value = s; };
  const supportedMime = () => {
    const list = ['audio/mp4;codecs=mp4a.40.2','audio/mp4','audio/webm;codecs=opus','audio/webm'];
    for (const m of list) if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
    return '';
  };
  const blobToDataURL = bl => new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=rej; fr.readAsDataURL(bl); });

  async function startRecording(){
    // getUserMedia 시도: data: URL / 일부 WebView에서는 실패 가능
    const hasGUM = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    if (!hasGUM) { alert('이 환경에서는 마이크 API를 사용할 수 없습니다. "시스템 녹음/파일 선택"을 이용하세요.'); return; }

    try{
      const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      chunks = []; mime = supportedMime();
      mediaRecorder = mime ? new MediaRecorder(stream,{mimeType:mime}) : new MediaRecorder(stream);
      ext = (mime && mime.includes('mp4')) ? 'm4a' : 'webm';

      mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
      mediaRecorder.onstop = async ()=>{
        blob = new Blob(chunks, { type: mime || (ext==='m4a' ? 'audio/mp4' : 'audio/webm') });
        fileName = `recording_${new Date().toISOString().replace(/[:.]/g,'-')}.${ext}`;
        player.src = URL.createObjectURL(blob);
        sendBtn.disabled = false;
        setMeta(`Audio Ready: ${fileName} (${blob.type}, ${blob.size} bytes)`);
        statusEl.textContent = '준비됨';
      };

      mediaRecorder.start(250);
      startTs = Date.now();
      tickId = setInterval(()=> timerEl.textContent = fmt(Date.now()-startTs), 250);
      recBtn.disabled = true; stopBtn.disabled = false; sendBtn.disabled = true;
      statusEl.textContent = '녹음 중…';
    }catch(e){
      // 여기로 떨어지면 권한/환경 문제 → 폴백 안내
      console.error(e);
      alert('마이크 권한/녹음 시작 실패.\n• data: URL/일부 WebView에서는 차단될 수 있어요.\n• Safari에서 HTTPS 도메인으로 열거나, 아래 "시스템 녹음/파일 선택"을 사용하세요.');
    }
  }

  function stopRecording(){
    if (!mediaRecorder) return;
    mediaRecorder.stop();
    mediaRecorder.stream.getTracks().forEach(t=>t.stop());
    clearInterval(tickId);
    recBtn.disabled = false; stopBtn.disabled = true;
  }

  // 시스템 녹음/파일 폴백
  fileIn.addEventListener('change', async ()=>{
    if (!fileIn.files?.[0]) return;
    const f = fileIn.files[0];
    blob = f; ext = (/\.(m4a|mp4)$/i.test(f.name) ? 'm4a' : (f.type.includes('mp4')?'m4a':'webm'));
    fileName = f.name || `recording_${new Date().toISOString().replace(/[:.]/g,'-')}.${ext}`;
    player.src = URL.createObjectURL(f);
    sendBtn.disabled = false;
    setMeta(`Audio Ready: ${fileName} (${f.type || 'audio/*'}, ${f.size} bytes)`);
    statusEl.textContent = '파일 선택됨';
    log(`폴백 파일 수신: ${fileName}`);
  });

  async function sendChunks(){
    if (!blob) { alert('먼저 녹음하거나 파일을 선택하세요.'); return; }
    statusEl.textContent = '인코딩 중…';
    const dataURL = await blobToDataURL(blob); // data:audio/...;base64,AAAA...
    dataTA.value = dataURL; // 백업용 본문 저장

    const comma = dataURL.indexOf(',');
    const base64 = dataURL.slice(comma+1);
    const total = Math.ceil(base64.length / CHUNK_CHARS);
    const id = `rec-${Date.now()}`;

    // 메시지 브리지 경로
    const hasBridge = postToShortcuts({ type:'audioStart', id, name:fileName, mime:blob.type || 'audio/*', total });
    if (hasBridge) {
      for (let i=0;i<total;i++){
        const part = base64.slice(i*CHUNK_CHARS, (i+1)*CHUNK_CHARS);
        postToShortcuts({ type:'audioChunk', id, idx:i, data:part });
        statusEl.textContent = `전송 중… (${i+1}/${total})`;
      }
      postToShortcuts({ type:'audioDone', id });
      statusEl.textContent = '전송 완료';
      log(`전송 완료: ${fileName}, 청크 ${total}개`);
      return;
    }

    // 브리지 없으면 제목/본문 백업 경로 사용
    document.title = `Audio DataURL Ready: ${fileName}`;
    statusEl.textContent = '브리지 없음: 제목/본문에 기록됨';
    log('Receive Web Page Messages를 찾지 못해 DataURL을 본문(#dataurl)에 기록했습니다.');
  }

  // UI
  recBtn.addEventListener('click', ()=> startRecording());
  stopBtn.addEventListener('click', stopRecording);
  pickBtn.addEventListener('click', ()=> fileIn.click());
  sendBtn.addEventListener('click', ()=> sendChunks());

  // WebView를 열자마자 준비 신호 (옵션)
  postToShortcuts({ type:'ready', ts:Date.now() });
})();
</script>
</body>
</html>
