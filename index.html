<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Record → Clipboard (Manual Close)</title>
<style>
  body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto; padding:20px; }
  h1 { font-size:18px; margin:0 0 10px; }
  .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0; }
  button { padding:10px 14px; border:0; border-radius:10px; background:#007aff; color:#fff; font-size:16px; }
  button[disabled]{ opacity:.5; }
  #timer { min-width:80px; font-variant-numeric: tabular-nums; }
  audio { width:100%; margin-top:12px; }

  /* (옵션) 전달 텍스트 표시 */
  .incoming-wrap { margin:12px 0 16px; padding:10px 12px; border:1px solid #e5e5ea; border-radius:10px; background:#f7f7f9; }
  .incoming-label { font-size:12px; color:#666; margin-bottom:6px; }
  .incoming-text { white-space:pre-wrap; word-break:break-word; font-size:16px; }

  /* 폴백용 숨김 영역 */
  #b64, #dataurl { position:fixed; bottom:-9999px; left:0; width:1px; height:1px; opacity:0.001; }

  /* 녹음 중(Stop)일 때 버튼 빨간색 */
  .danger { background:#ff3b30 !important; }
</style>
</head>
<body>
  <h1>오디오 녹음</h1>

  <!-- (옵션) 단축어에서 ?message=... 또는 #message=... 로 전달한 텍스트 표시 -->
  <div class="incoming-wrap" id="incomingBox" style="display:none;">
    <div class="incoming-label">Received text</div>
    <div class="incoming-text" id="incomingText"></div>
  </div>

  <div class="row">
    <button id="recordBtn">Record</button>
    <span id="timer">00:00</span>
  </div>

  <audio id="player" controls></audio>

  <!-- 폴백용 -->
  <textarea id="b64" readonly></textarea>
  <textarea id="dataurl" readonly></textarea>

<script>
(() => {
  // ---------- (옵션) 전달 텍스트 표시 ----------
  function readIncoming() {
    const qs = new URLSearchParams(location.search);
    let v = qs.get('message');
    if (!v && location.hash) {
      const h = location.hash.replace(/^#/, '');
      if (h.startsWith('message=')) v = h.slice('message='.length);
    }
    if (!v) return '';
    try { v = decodeURIComponent(v); } catch {}
    return v;
  }
  const msg = readIncoming();
  if (msg) {
    incomingText.innerText = msg;
    incomingBox.style.display = 'block';
  }

  // ---------- 녹음 ----------
  const recordBtn = document.getElementById('recordBtn');
  const timerEl   = document.getElementById('timer');
  const player    = document.getElementById('player');
  const b64TA     = document.getElementById('b64');
  const dataTA    = document.getElementById('dataurl');

  let mediaRecorder=null, chunks=[], startTs=0, tickId=0;
  let countdownToken = 0;

  const fmt = ms => {
    const s=Math.floor(ms/1000),
          m=String(Math.floor(s/60)).padStart(2,'0'),
          ss=String(s%60).padStart(2,'0');
    return `${m}:${ss}`;
  };
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function pickMime(){
    const cands = [
      'audio/mp4;codecs=mp4a.40.2', // m4a 선호
      'audio/mp4',
      'audio/webm;codecs=opus',
      'audio/webm'
    ];
    for (const m of cands){
      if (window.MediaRecorder?.isTypeSupported?.(m)) return m;
    }
    return '';
  }

  function blobToDataURL(blob){
    return new Promise((res,rej)=>{
      const fr=new FileReader();
      fr.onload = ()=>res(fr.result); // data:audio/...;base64,AAAA...
      fr.onerror= rej;
      fr.readAsDataURL(blob);
    });
  }

  // === 복사 유틸(강화) ===
  async function robustCopy(text){
    // 너무 긴 문자열이면 경고(그래도 시도)
    if (text && text.length > 1_000_000) {
      console.warn('Data URL is very long; iOS may reject clipboard write.');
      // 사용자에게도 애매하면 알려주고 계속
      // alert('녹음 길이가 길어 클립보드로 보내기 어려울 수 있습니다. (그래도 시도합니다)');
    }

    // A) ClipboardItem 경로(텍스트 Blob) — 일부 환경에서 성공률↑
    try{
      if (navigator.clipboard && window.isSecureContext && typeof ClipboardItem !== 'undefined') {
        const item = new ClipboardItem({ 'text/plain': new Blob([text], { type: 'text/plain' }) });
        await navigator.clipboard.write([item]);
        return true;
      }
    }catch(e){ /* continue */ }

    // B) writeText
    try{
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return true;
      }
    }catch(e){ /* continue */ }

    // C) execCommand 폴백(임시 textarea)
    try{
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.setAttribute('readonly','');
      ta.style.position = 'fixed';
      ta.style.left = '0';
      ta.style.bottom = '0';
      ta.style.opacity = '0.001';
      document.body.appendChild(ta);
      ta.focus(); ta.select(); ta.setSelectionRange(0, ta.value.length);
      const ok = document.execCommand('copy');
      document.body.removeChild(ta);
      if (ok) return true;
    }catch(e){ /* continue */ }

    // D) 폴백 textarea
    try{
      b64TA.value = text;
      b64TA.focus(); b64TA.select(); b64TA.setSelectionRange(0, b64TA.value.length);
      const ok3 = document.execCommand('copy');
      if (ok3) return true;
    }catch(e){}

    return false;
  }

  function startRecTick(){
    startTs = Date.now();
    clearInterval(tickId);
    tickId = setInterval(()=> timerEl.textContent = fmt(Date.now()-startTs), 250);
  }

  async function startRec(){
    if (!navigator.mediaDevices?.getUserMedia){
      alert('이 환경에서는 마이크 접근을 지원하지 않습니다.');
      return;
    }
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    chunks = [];
    const mime = pickMime();
    mediaRecorder = mime ? new MediaRecorder(stream, { mimeType: mime }) : new MediaRecorder(stream);

    mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };

    startRecTick();
    mediaRecorder.start(250);

    // 버튼을 녹음 중(빨강)으로 전환 & 카운트다운(2→1, 각 0.8s) 표시
    recordBtn.classList.add('danger');
    showCountdownWhileRecording();
  }

  // Stop 클릭 핸들러 안에서: onstop 대기 + 타임아웃 → DataURL → 클립보드
  async function stopAndCopyInClick(){
    if (!mediaRecorder) throw new Error('NO_RECORDER');

    countdownToken++; // 카운트다운 취소

    // 마지막 데이터 강제 플러시
    try { mediaRecorder.requestData && mediaRecorder.requestData(); } catch {}

    // onstop 대기 + 타임아웃(1.5s)
    const stopped = new Promise((resolve) => {
      const prev = mediaRecorder.onstop;
      mediaRecorder.onstop = (ev) => {
        try { prev && prev(ev); } catch {}
        resolve('onstop');
      };
    });
    const timeout = new Promise((resolve) => setTimeout(()=>resolve('timeout'), 1500));

    try { mediaRecorder.stop(); } catch (e) {}
    try { mediaRecorder.stream && mediaRecorder.stream.getTracks().forEach(t=>t.stop()); } catch {}

    await Promise.race([stopped, timeout]);

    clearInterval(tickId);
    timerEl.textContent = '00:00';

    const type = (mediaRecorder && mediaRecorder.mimeType) || 'audio/mp4';
    const blob = new Blob(chunks || [], { type });
    chunks = [];

    try { player.src = URL.createObjectURL(blob); } catch {}

    const dataURL = await blobToDataURL(blob);
    dataTA.value = dataURL;

    // ✅ 클릭 핸들러 체인 내에서 즉시 복사 시도 (강화된 robustCopy)
    const ok = await robustCopy(dataURL);
    if (!ok) {
      alert('클립보드 복사에 실패했습니다. (E-clipboard)\n녹음 길이를 줄여 보거나, 페이지에서 직접 복사해 주세요.');
      throw new Error('CLIPBOARD_FAILED');
    }

    // 버튼 UI 복구
    recordBtn.textContent = 'Record';
    recordBtn.classList.remove('danger');
  }

  function stopRecUIOnly(){
    recordBtn.textContent = 'Record';
    recordBtn.classList.remove('danger');
  }

  async function showCountdownWhileRecording(){
    const myToken = ++countdownToken;
    const steps = ['2','1'];   // 2 → 1
    const stepDelay = 800;     // 각 0.8초
    for (const label of steps){
      if (myToken !== countdownToken) return;
      if (!mediaRecorder || mediaRecorder.state !== 'recording') return;
      recordBtn.textContent = label;
      await sleep(stepDelay);
    }
    if (myToken === countdownToken && mediaRecorder && mediaRecorder.state === 'recording'){
      recordBtn.textContent = 'Stop';
    }
  }

  async function onRecordClick(){
    try {
      if (mediaRecorder && mediaRecorder.state === 'recording'){
        recordBtn.disabled = true;
        await stopAndCopyInClick();
        recordBtn.disabled = false;
      } else {
        await startRec();   // 즉시 녹음 시작
      }
    } catch(e){
      console.error(e);
      alert('마이크/클립보드 처리 중 오류가 발생했습니다. (E-global)');
      // UI 복구
      clearInterval(tickId);
      timerEl.textContent = '00:00';
      stopRecUIOnly();
      mediaRecorder = null;
    }
  }

  recordBtn.addEventListener('click', onRecordClick);

  // HTTPS/localhost 권장 (클립보드 최신 API 동작 안정성)
  if (!(location.protocol === 'https:' || ['localhost','127.0.0.1'].includes(location.hostname))) {
    console.warn('HTTPS 또는 localhost에서 실행해야 클립보드/마이크가 안정적으로 동작합니다.');
  }
})();
</script>
</body>
</html>
